"""
Unified API server for the stock simulator.
- Uses port 5001 by default
- CORS enabled
- JSON shape matches frontend expectations:
  - success: { message, ...data_fields }
  - error:   { error, ...optional_fields }
"""

from flask import Flask, jsonify, request, send_from_directory, Response
from flask_cors import CORS
from pathlib import Path
from services.prices import make_default_market, Stock
from trading import Portfolio
import datetime
import shutil
import logging
from logging.handlers import RotatingFileHandler

# missing imports used later
import re
import json
import io
from io import StringIO
import csv
from collections import defaultdict

BASE_DIR = Path(__file__).resolve().parent
STATIC_DIR = BASE_DIR / "static"
DATA_DIR = BASE_DIR / "data"
PORTFOLIO_FILE = DATA_DIR / "portfolio.json"

app = Flask(__name__, static_folder=str(STATIC_DIR))
CORS(app)

# -----------------------
# Logging setup
# -----------------------
LOG_DIR = BASE_DIR / "logs"
LOG_DIR.mkdir(exist_ok=True)
LOG_FILE = LOG_DIR / "server.log"

logger = logging.getLogger("stock_app")
logger.setLevel(logging.INFO)

handler = RotatingFileHandler(
    filename=str(LOG_FILE),
    maxBytes=3_000_000,
    backupCount=3
)
formatter = logging.Formatter("%(asctime)s  %(levelname)s  %(message)s")
handler.setFormatter(formatter)

if not logger.handlers:
    logger.addHandler(handler)


@app.before_request
def log_request():
    try:
        body = request.get_data(as_text=True)
    except Exception:
        body = ""
    logger.info(f"REQ {request.remote_addr} {request.method} {request.path} body={body}")


# -----------------------
# Helper functions
# -----------------------
def resp_ok(message="ok", data=None, status=200):
    """
    Success response:

    {
      "success": true,
      "message": "text",
      ...data fields merged here...
    }
    """
    payload = {"success": True, "message": message}
    if isinstance(data, dict):
        payload.update(data)
    return jsonify(payload), status


def resp_err(message="error", status=400, data=None):
    """
    Error response:

    {
      "success": false,
      "error": "message",
      ...optional extra fields...
    }
    """
    payload = {"success": False, "error": message}
    if isinstance(data, dict):
        payload.update(data)
    return jsonify(payload), status


def read_json_request(require_json=False):
    try:
        j = request.get_json(silent=True)
    except Exception:
        j = None
    if require_json and j is None:
        return None, resp_err("Request body must be valid JSON", 400)
    return j or {}, None


def ensure_data_dir():
    DATA_DIR.mkdir(parents=True, exist_ok=True)


# --- simple per-user helpers (paste right after resp_ok/resp_err/read_json_request/ensure_data_dir) ---
def _get_user_from_request():
    """
    Return safe username from query ?user=NAME or header X-User (lowercased).
    Only allow a-z, 0-9, underscore and dash.
    """
    username = None
    if request.args.get("user"):
        username = request.args.get("user")
    else:
        username = request.headers.get("X-User") or None
    if not username:
        return None
    username = str(username).strip().lower()
    if not re.match(r"^[a-z0-9_\-]+$", username):
        return None
    return username


def _user_portfolio_path(username: str):
    """
    Return Path to the user's portfolio file under the existing DATA_DIR.
    """
    ensure_data_dir()
    safe = username.lower()
    return DATA_DIR / f"portfolio_{safe}.json"


def load_portfolio_for_user(username: str):
    """
    Load trading.Portfolio for a given username.
    If not present, create default portfolio file and return a Portfolio instance.
    """
    from trading import Portfolio as _Portfolio
    path = _user_portfolio_path(username)
    if not path.exists():
        # create default portfolio file
        p = _Portfolio()
        data = {
            "cash": p.cash,
            "holdings": dict(p.holdings),
            "trade_history": p.trade_history,
            # try to keep initial_cash consistent if Portfolio exposes it
            "initial_cash": getattr(p, "initial_cash", getattr(p, "cash", 10000.0))
        }
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        # return a fresh Portfolio instance matching file content
        return _Portfolio(cash=p.cash)
    # file exists -> load JSON and build Portfolio object
    # Use utf-8-sig to tolerate BOMs written by Windows editors/tools
    with path.open("r", encoding="utf-8-sig") as f:
        data = json.load(f)
    p = _Portfolio(cash=data.get("cash", 10000.0))
    holdings = data.get("holdings", {}) or {}
    for sym, qty in holdings.items():
        try:
            p.holdings[sym.upper()] = int(qty)
        except Exception:
            continue
    p.trade_history = data.get("trade_history", []) or data.get("trades", [])
    # if file includes initial_cash, set if Portfolio supports it
    if hasattr(p, "initial_cash"):
        try:
            p.initial_cash = float(data.get("initial_cash", getattr(p, "initial_cash", 10000.0)))
        except Exception:
            pass
    return p

def save_portfolio_for_user(username: str, portfolio):
    """
    Save a Portfolio instance (or dict) to the user's file.
    """
    path = _user_portfolio_path(username)
    if isinstance(portfolio, dict):
        data = portfolio
    else:
        data = {
            "cash": getattr(portfolio, "cash", 0.0),
            "holdings": dict(getattr(portfolio, "holdings", {})),
            "trade_history": getattr(portfolio, "trade_history", []),
        }
        # only include initial_cash if Portfolio exposes it explicitly
        if hasattr(portfolio, "initial_cash"):
            try:
                data["initial_cash"] = float(getattr(portfolio, "initial_cash"))
            except Exception:
                pass

    ensure_data_dir()
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


# -----------------------
# Small utility helpers for trades and dates (these were referenced but missing)
# -----------------------
def _parse_trade(t):
    """
    Normalize a trade entry to a dict with keys:
    { date, type, symbol, qty, price }
    Accepts dicts or simple structures.
    """
    if t is None:
        return {"date": None, "type": None, "symbol": None, "qty": 0, "price": 0.0}
    if isinstance(t, str):
        # try JSON decode
        try:
            td = json.loads(t)
        except Exception:
            # fallback: attempt to parse very simple CSV-like "date,type,symbol,qty,price"
            parts = [p.strip() for p in t.split(",")]
            while len(parts) < 5:
                parts.append(None)
            return {
                "date": parts[0],
                "type": parts[1],
                "symbol": (parts[2] or "").upper(),
                "qty": int(parts[3] or 0),
                "price": float(parts[4] or 0.0),
            }
        t = td

    # assume dict-like
    return {
        "date": t.get("date") if isinstance(t, dict) else None,
        "type": (t.get("type") if isinstance(t, dict) else None),
        "symbol": ((t.get("symbol") or "").upper() if isinstance(t, dict) else None),
        "qty": int(t.get("qty") or 0) if isinstance(t, dict) else 0,
        "price": float(t.get("price") or 0.0) if isinstance(t, dict) else 0.0,
    }


def _date_str_to_date(d):
    """
    Accepts a date, datetime.date, datetime.datetime or ISO string and returns datetime.date or None.
    """
    if d is None:
        return None
    if isinstance(d, datetime.date) and not isinstance(d, datetime.datetime):
        return d
    if isinstance(d, datetime.datetime):
        return d.date()
    if isinstance(d, str):
        # try several formats
        for fmt in ("%Y-%m-%d", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S"):
            try:
                return datetime.datetime.strptime(d, fmt).date()
            except Exception:
                continue
        # last resort: try fromisoformat
        try:
            return datetime.date.fromisoformat(d)
        except Exception:
            return None
    return None


def _price_on_date(stock: Stock, date_obj):
    """
    Given a stock and a datetime.date, return the price for that date if available.
    If exact date not found, return the most recent price before that date; otherwise None.
    Stock.history assumed to be list of (date, price) where date is date or str.
    """
    if stock is None or date_obj is None:
        return None
    history = list(stock.history)
    # normalize history to list of (date, price) with date as datetime.date
    hist_norm = []
    for d, p in history:
        if isinstance(d, str):
            dd = _date_str_to_date(d)
        elif isinstance(d, datetime.datetime):
            dd = d.date()
        else:
            dd = d
        if dd:
            hist_norm.append((dd, float(p)))
    # sort by date ascending
    hist_norm.sort(key=lambda x: x[0])
    chosen = None
    for dd, p in hist_norm:
        if dd <= date_obj:
            chosen = p
        else:
            break
    return chosen


# -----------------------
# Global market instance
# -----------------------
market = make_default_market()


# -----------------------
# Serve frontend
# -----------------------
@app.route("/", methods=["GET"])
def root():
    index_path = STATIC_DIR / "index.html"
    if index_path.exists():
        return send_from_directory(str(STATIC_DIR), "index.html")
    return resp_ok(
        "Stock Simulator API running. Visit /api/prices",
        {"routes": ["/api/prices", "/api/portfolio"]}
    )


@app.route("/static/<path:filename>", methods=["GET"])
def static_files(filename):
    file_path = STATIC_DIR / filename
    if file_path.exists():
        return send_from_directory(str(STATIC_DIR), filename)
    return resp_err("Not found", 404)


# -----------------------
# API endpoints
# -----------------------
@app.route("/api/prices", methods=["GET"])
def api_prices():
    try:
        stocks = market.list_prices()
        return resp_ok(
            "prices returned",
            {"date": str(market.date), "prices": stocks}
        )
    except Exception as e:
        logger.exception("Failed to list prices")
        return resp_err(f"Failed to list prices: {e}", 500)


@app.route("/api/login", methods=["POST"])
def api_login():
    j, err = read_json_request(require_json=True)
    if err:
        return err

    username = (j.get("username") or "").strip().lower()
    if not username:
        return resp_err("username is required", 400)

    # validate allowed chars
    if not re.match(r"^[a-z0-9_\-]+$", username):
        return resp_err("invalid username (allowed: a-z, 0-9, _ , -)", 400)

    # create/load portfolio file
    try:
        portfolio = load_portfolio_for_user(username)
        save_portfolio_for_user(username, portfolio)

        return resp_ok("login ok", {
            "username": username,
            "portfolio_file": str(_user_portfolio_path(username))
        })
    except Exception as e:
        logger.exception("Login failed")
        return resp_err(f"login failed: {e}", 500)


@app.route("/api/next", methods=["POST"])
def api_next():
    j, err = read_json_request(require_json=False)
    if err:
        return err

    days = j.get("days", request.args.get("days", 1))
    try:
        days = int(days)
    except Exception:
        return resp_err("days must be an integer", 400)
    if days < 1:
        return resp_err("days must be >= 1", 400)
    if days > 3650:
        return resp_err("days too large (max 3650)", 400)

    try:
        market.simulate_days(days)
        logger.info(f"SIMULATE days={days} new_date={market.date}")
        return resp_ok(
            f"Advanced {days} day(s)",
            {"date": str(market.date)}
        )
    except Exception as e:
        logger.exception("Simulation failed")
        return resp_err(f"Simulation failed: {e}", 500)


@app.route("/api/addstock", methods=["POST"])
def api_addstock():
    j, err = read_json_request(require_json=True)
    if err:
        return err

    symbol = (j.get("symbol") or "").strip().upper()
    if not symbol:
        return resp_err("symbol is required", 400)
    if symbol in market.stocks:
        return resp_err("stock already exists", 400)

    try:
        price = float(j.get("price"))
    except Exception:
        return resp_err("price must be a number", 400)

    try:
        mu = float(j.get("mu", 0.0005))
        sigma = float(j.get("sigma", 0.02))
    except Exception:
        return resp_err("mu and sigma must be numbers", 400)

    try:
        stock = Stock(symbol, price, mu, sigma)
        market.add_stock(stock)
        logger.info(f"ADDSTOCK {symbol} price={price} mu={mu} sigma={sigma}")
        return resp_ok(
            "stock added",
            {"symbol": symbol, "price": price, "mu": mu, "sigma": sigma},
            201,
        )
    except Exception as e:
        logger.exception("Failed to add stock")
        return resp_err(f"Failed to add stock: {e}", 500)


@app.route("/api/buy", methods=["POST"])
def api_buy():
    j, err = read_json_request(require_json=True)
    if err:
        return err
    symbol = (j.get("symbol") or "").upper()
    qty = j.get("qty")
    try:
        qty = int(qty)
    except Exception:
        return resp_err("qty must be an integer", 400)
    if qty <= 0:
        return resp_err("qty must be > 0", 400)
    if symbol not in market.stocks:
        return resp_err("unknown symbol", 400)

    # <-- per-user support -->
    username = _get_user_from_request()
    if username:
        portfolio = load_portfolio_for_user(username)
    else:
        portfolio = Portfolio.load()

    price = market.stocks[symbol].price
    try:
        portfolio.buy(symbol, price, qty, market.date)
        # persist per-user or global
        if username:
            save_portfolio_for_user(username, portfolio)
        else:
            portfolio.save()
        logger.info(f"BUY {symbol} qty={qty} price={price:.2f} cash_after={portfolio.cash:.2f}")
        return resp_ok("bought", {"symbol": symbol, "qty": qty, "price": price, "cash": portfolio.cash, "net_worth": portfolio.net_worth(market)})
    except Exception as e:
        logger.exception("Buy failed")
        return resp_err(str(e), 400)


@app.route("/api/sell", methods=["POST"])
def api_sell():
    j, err = read_json_request(require_json=True)
    if err:
        return err
    symbol = (j.get("symbol") or "").upper()
    qty = j.get("qty")
    try:
        qty = int(qty)
    except Exception:
        return resp_err("qty must be an integer", 400)
    if qty <= 0:
        return resp_err("qty must be > 0", 400)
    if symbol not in market.stocks:
        return resp_err("unknown symbol", 400)

    # <-- per-user support -->
    username = _get_user_from_request()
    if username:
        portfolio = load_portfolio_for_user(username)
    else:
        portfolio = Portfolio.load()

    price = market.stocks[symbol].price
    try:
        portfolio.sell(symbol, price, qty, market.date)
        # persist per-user or global
        if username:
            save_portfolio_for_user(username, portfolio)
        else:
            portfolio.save()
        logger.info(f"SELL {symbol} qty={qty} price={price:.2f} cash_after={portfolio.cash:.2f}")
        return resp_ok("sold", {"symbol": symbol, "qty": qty, "price": price, "cash": portfolio.cash, "net_worth": portfolio.net_worth(market)})
    except Exception as e:
        logger.exception("Sell failed")
        return resp_err(str(e), 400)


@app.route("/api/portfolio", methods=["GET"])
def api_portfolio():
    """
    - Works whether Portfolio.load() returns a dict or an object.
    - Returns: { message, cash, net_worth, holdings: [...] }
    """
    try:
        username = _get_user_from_request()
        if username:
            portfolio = load_portfolio_for_user(username)
        else:
            portfolio = Portfolio.load()

        if isinstance(portfolio, dict):
            cash = portfolio.get("cash", 0.0)
            holdings_map = portfolio.get("holdings", {}) or {}
        else:
            cash = getattr(portfolio, "cash", 0.0)
            holdings_map = getattr(portfolio, "holdings", {}) or {}

        holdings = []
        for sym, qty in holdings_map.items():
            try:
                qty_num = int(qty)
            except Exception:
                continue

            stock = market.stocks.get(sym.upper())
            price = stock.price if stock is not None else None
            value = (price * qty_num) if (price is not None) else None

            holdings.append(
                {"symbol": sym, "qty": qty_num, "price": price, "value": value}
            )

        net_worth = None
        if isinstance(portfolio, dict):
            net_worth = portfolio.get("net_worth")
        else:
            try:
                net_worth = portfolio.net_worth(market)
            except Exception:
                net_worth = None

        if net_worth is None:
            approx = float(cash or 0.0)
            for h in holdings:
                if h["value"] is not None:
                    approx += float(h["value"])
            net_worth = approx

        return resp_ok(
            "portfolio",
            {"cash": cash, "net_worth": net_worth, "holdings": holdings},
        )
    except Exception as e:
        logger.exception("Failed to load portfolio")
        return resp_err(f"Failed to load portfolio: {e}", 500)


@app.route("/api/history", methods=["GET"])
def api_history():
    """
    Return trade history for user (if ?user=...) or global portfolio otherwise.
    """
    try:
        username = _get_user_from_request()
        if username:
            portfolio = load_portfolio_for_user(username)
        else:
            portfolio = Portfolio.load()

        if isinstance(portfolio, dict):
            trades = portfolio.get("trade_history") or portfolio.get("trades") or []
        else:
            trades = getattr(portfolio, "trade_history", None) or getattr(portfolio, "trades", []) or []
        if trades is None:
            trades = []
        return resp_ok("history", {"trades": trades})
    except Exception as e:
        logger.exception("Failed to load history")
        return resp_err(f"Failed to load history: {e}", 500)


@app.route("/api/stats", methods=["GET"])
def api_stats():
    """
    Returns simple aggregated stats based on the portfolio and current market.
    """
    try:
        username = _get_user_from_request()
        if username:
            portfolio = load_portfolio_for_user(username)
            if isinstance(portfolio, dict):
                trades = portfolio.get("trade_history") or portfolio.get("trades") or []
                start_cash = float(portfolio.get("initial_cash", 10000.0) or 10000.0)
                current_cash = float(portfolio.get("cash", 0.0) or 0.0)
            else:
                trades = getattr(portfolio, "trade_history", None) or getattr(portfolio, "trades", []) or []
                start_cash = float(getattr(portfolio, "initial_cash", 10000.0) or 10000.0)
                current_cash = float(getattr(portfolio, "cash", 0.0) or 0.0)
        else:
            portfolio = Portfolio.load()
            trades = portfolio.get("trade_history") if isinstance(portfolio, dict) else getattr(portfolio, "trade_history", None) or getattr(portfolio, "trades", []) or []
            start_cash = float(portfolio.get("initial_cash", 10000.0) if isinstance(portfolio, dict) else getattr(portfolio, "initial_cash", 10000.0) or 10000.0)
            current_cash = float(portfolio.get("cash", 0.0) if isinstance(portfolio, dict) else getattr(portfolio, "cash", 0.0) or 0.0)

        total_buys = 0.0
        total_sells = 0.0
        for t in trades:
            tr = _parse_trade(t)
            amt = tr["price"] * tr["qty"]
            if tr["type"] and tr["type"].upper().startswith("B"):
                total_buys += amt
            elif tr["type"] and tr["type"].upper().startswith("S"):
                total_sells += amt

        net_worth = None
        if isinstance(portfolio, dict):
            net_worth = portfolio.get("net_worth")
            try:
                net_worth = float(net_worth) if net_worth is not None else None
            except Exception:
                net_worth = None
        else:
            try:
                net_worth = float(portfolio.net_worth(market))
            except Exception:
                net_worth = None

        if net_worth is None:
            approx = float(current_cash or 0.0)
            holdings_map = portfolio.get("holdings", {}) if isinstance(portfolio, dict) else getattr(portfolio, "holdings", {}) or {}
            for sym, qty in holdings_map.items():
                s = market.stocks.get(sym.upper())
                if s is not None:
                    approx += float(s.price) * int(qty)
            net_worth = approx

        num_trades = len(trades) if trades is not None else 0
        net_invested = total_buys - total_sells
        total_profit = net_worth - (float(start_cash) or 10000.0)

        return resp_ok("stats", {
            "total_buys": round(total_buys, 6),
            "total_sells": round(total_sells, 6),
            "net_invested": round(net_invested, 6),
            "total_profit": round(total_profit, 6),
            "num_trades": num_trades
        })
    except Exception as e:
        logger.exception("Failed to compute stats")
        return resp_err(f"Failed to compute stats: {e}", 500)


@app.route("/api/price_history/<string:symbol>", methods=["GET"])
def api_price_history(symbol):
    """
    Returns: { message, symbol, dates: [...], prices: [...] }
    Which matches JS: data.dates, data.prices
    """
    symbol = symbol.upper()
    if symbol not in market.stocks:
        return resp_err("unknown symbol", 404)

    stock = market.stocks[symbol]
    history_list = list(stock.history)

    dates = [str(d) for d, _ in history_list]
    prices = [float(p) for _, p in history_list]

    return resp_ok(
        "price history",
        {"symbol": symbol, "dates": dates, "prices": prices},
    )


@app.route("/api/reset", methods=["POST"])
def api_reset():
    """
    Reset portfolio for the given user (if ?user=...) or global portfolio otherwise.
    Creates a timestamped backup of the existing portfolio file before resetting.
    """
    try:
        username = _get_user_from_request()
        ensure_data_dir()

        # determine file path and perform backup if file exists
        if username:
            path = _user_portfolio_path(username)
        else:
            path = PORTFOLIO_FILE

        backup_name = None
        if path.exists():
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = path.parent / f"{path.stem}_backup_{ts}{path.suffix}"
            try:
                shutil.copy2(path, backup_name)
            except Exception:
                # if backup fails, log but continue (we still try to create default)
                logger.exception("Failed to backup portfolio before reset")

        # create default portfolio and save to correct path
        default_port = Portfolio()
        if username:
            save_portfolio_for_user(username, default_port)
        else:
            # ensure data dir
            ensure_data_dir()
            default_port.save()

        # also reset market to default
        global market
        market = make_default_market()

        logger.info(f"RESET performed; user={username} backup={backup_name}")
        return resp_ok("reset complete", {"backup": str(backup_name) if backup_name else None})
    except Exception as e:
        logger.exception("Reset failed")
        return resp_err(f"Reset failed: {e}", 500)


@app.route("/api/history_csv", methods=["GET"])
def api_history_csv():
    """
    Return trade history as CSV attachment for user (if ?user=...) or global otherwise.
    """
    try:
        username = _get_user_from_request()
        if username:
            portfolio = load_portfolio_for_user(username)
        else:
            portfolio = Portfolio.load()

        trades = portfolio.get("trade_history") if isinstance(portfolio, dict) else getattr(portfolio, "trade_history", None) or getattr(portfolio, "trades", []) or []
        si = StringIO()
        writer = csv.writer(si)
        writer.writerow(["date", "type", "symbol", "qty", "price"])
        for t in trades:
            tr = _parse_trade(t)
            writer.writerow([tr["date"], tr["type"], tr["symbol"], tr["qty"], tr["price"]])
        csv_data = si.getvalue()
        filename = f"trade_history{'_' + username if username else ''}.csv"
        return Response(csv_data, mimetype="text/csv", headers={
            "Content-Disposition": f"attachment; filename={filename}"
        })
    except Exception as e:
        logger.exception("Failed to build CSV")
        return resp_err(f"Failed to build CSV: {e}", 500)


@app.route("/api/performance", methods=["GET"])
def api_performance():
    """
    Returns time series performance based on portfolio.trade_history and market stock histories.
    Response data:
    {
      "dates": ["2025-11-19", ...],
      "net_worth": [10000.00, ...]
    }
    """
    try:
        username = _get_user_from_request()
        if username:
            portfolio = load_portfolio_for_user(username)
            trades_raw = portfolio.get("trade_history") or portfolio.get("trades") or []
        else:
            portfolio = Portfolio.load()
            trades_raw = portfolio.get("trade_history") if isinstance(portfolio, dict) else getattr(portfolio, "trade_history", None) or getattr(portfolio, "trades", []) or []

        trades = [_parse_trade(t) for t in trades_raw]

        # collect all candidate dates from market stock histories
        date_set = set()
        for stock in market.stocks.values():
            for d, _ in stock.history:
                if isinstance(d, str):
                    dd = _date_str_to_date(d)
                elif isinstance(d, datetime.datetime):
                    dd = d.date()
                else:
                    dd = d
                if dd:
                    date_set.add(dd)
        md = getattr(market, "date", None)
        if isinstance(md, (str,)):
            md = _date_str_to_date(md)
        elif isinstance(md, datetime.datetime):
            md = md.date()
        if md:
            date_set.add(md)

        if not date_set:
            today = datetime.date.today()
            try:
                nw = float(portfolio.net_worth(market)) if not isinstance(portfolio, dict) else float(portfolio.get("net_worth") or portfolio.get("cash", 10000.0))
            except Exception:
                nw = float(portfolio.get("cash", 10000.0)) if isinstance(portfolio, dict) else float(getattr(portfolio, "cash", 10000.0))
            return resp_ok("performance", {"dates": [str(today)], "net_worth": [nw]})

        dates = sorted(date_set)

        for tr in trades:
            tr["date_obj"] = _date_str_to_date(tr["date"]) or None
        trades = sorted(trades, key=lambda x: (x["date_obj"] or datetime.date.min))

        start_cash = 10000.0
        if isinstance(portfolio, dict):
            start_cash = float(portfolio.get("initial_cash", 10000.0) or 10000.0)
        else:
            start_cash = float(getattr(portfolio, "initial_cash", 10000.0) or 10000.0)

        cash = start_cash
        holdings = defaultdict(int)

        trades_by_date = defaultdict(list)
        for tr in trades:
            d = tr.get("date_obj")
            trades_by_date[d].append(tr)

        out_dates = []
        out_nw = []

        for d in dates:
            if d in trades_by_date:
                for tr in trades_by_date[d]:
                    typ = (tr.get("type") or "").upper()
                    sym = (tr.get("symbol") or "").upper()
                    qty = int(tr.get("qty") or 0)
                    price = float(tr.get("price") or 0.0)
                    if typ.startswith("B"):
                        cash -= price * qty
                        holdings[sym] += qty
                    elif typ.startswith("S"):
                        owned = holdings.get(sym, 0)
                        sell_qty = min(qty, owned)
                        cash += price * sell_qty
                        holdings[sym] = owned - sell_qty
            total = float(cash or 0.0)
            for sym, qty in list(holdings.items()):
                s = market.stocks.get(sym)
                if s is None:
                    continue
                p = _price_on_date(s, d)
                if p is None:
                    p = s.price
                total += p * qty
            out_dates.append(str(d))
            out_nw.append(round(total, 6))

        return resp_ok("performance", {"dates": out_dates, "net_worth": out_nw})
    except Exception as e:
        logger.exception("Failed to compute performance")
        return resp_err(f"Failed to compute performance: {e}", 500)


# -----------------------
# Generic error handlers
# -----------------------
@app.errorhandler(404)
def handle_404(e):
    return resp_err("Not found", 404)


@app.errorhandler(500)
def handle_500(e):
    return resp_err("Server error", 500)


# -----------------------
# Run server
# -----------------------
if __name__ == "__main__":
    print("Starting app on http://127.0.0.1:5001")
    app.run(host="127.0.0.1", port=5001, debug=True)
